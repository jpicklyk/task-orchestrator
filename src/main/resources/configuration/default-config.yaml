# Task Orchestrator Configuration
# This file configures orchestration behavior, status progressions, and quality gates
# Version: 2.0.0
#
# All sections in this file are actively used by the codebase.

version: "2.0.0"

# ============================================================================
# STATUS PROGRESSION CONFIGURATION (✅ IMPLEMENTED)
# ============================================================================
# Define allowed status flows for features and tasks
# Progression typically moves forward, but can move backward for rework
#
# IMPLEMENTATION: StatusValidator.kt loads and enforces these workflows

status_progression:
  features:
    # All valid feature statuses (v2.0) - 10 total statuses
    # Valid feature statuses (defined by FeatureStatus enum):
    # draft, planning, in-development, testing, validating, pending-review,
    # blocked, on-hold, completed, archived, deployed
    #
    # DRAFT: Initial draft state for exploring ideas and rough requirements.
    #        Use when: Feature concept is being explored but not ready for planning.
    #        Next steps: Refine requirements, then move to PLANNING.
    #
    # PLANNING: Defining detailed requirements, breaking down into tasks, and creating technical approach.
    #           Use when: Requirements are clear enough to start decomposing into actionable tasks.
    #           Next steps: Complete task breakdown, then move to IN_DEVELOPMENT.
    #
    # IN_DEVELOPMENT: Active implementation of tasks by specialists.
    #                 Use when: Tasks are being actively worked on by developers.
    #                 Next steps: Complete all tasks, then move to TESTING.
    #
    # TESTING: All development tasks complete, running test suite and validation.
    #          Use when: Implementation finished and ready for quality assurance.
    #          Next steps: Pass all tests, then move to VALIDATING.
    #
    # VALIDATING: Tests passed, performing final validation before completion.
    #             Use when: All tests pass and feature needs final review/approval.
    #             Next steps: Validation complete, move to COMPLETED or PENDING_REVIEW.
    #
    # PENDING_REVIEW: Awaiting human review/approval before marking complete.
    #                 Use when: Feature complete but requires stakeholder sign-off.
    #                 Next steps: Review approved, move to COMPLETED.
    #
    # BLOCKED: Feature blocked by external dependencies, technical issues, or missing resources.
    #          Use when: Cannot proceed due to blockers (API unavailable, infrastructure down, etc.).
    #          Emergency status: Can be entered from any state.
    #          Next steps: Resolve blocker, then resume previous flow.
    #
    # ON_HOLD: Feature temporarily paused due to priority changes, resource constraints, or pending decisions.
    #          Use when: Work paused intentionally (waiting for budget, design decisions, etc.).
    #          Emergency status: Can be entered from any state.
    #          Next steps: Resume when resources available, return to previous status or IN_DEVELOPMENT.
    #
    # COMPLETED: Feature complete, validated, and delivered.
    #            Use when: All work finished, tests pass, validation complete.
    #            Terminal status: No further progression.
    #
    # ARCHIVED: Feature archived for historical reference (obsolete, replaced, or superseded).
    #           Use when: Feature is no longer active but kept for reference.
    #           Emergency status: Can be entered from any state.
    #           Terminal status: No further progression.

    # Default flow for software development
    default_flow: [draft, planning, in-development, testing, validating, completed]

    # Alternative flows for different feature types
    rapid_prototype_flow: [draft, in-development, completed]  # Skip planning/testing
    experimental_flow: [draft, in-development, archived]  # Experiments can skip completion
    with_review_flow: [draft, planning, in-development, testing, validating, pending-review, completed]  # Full review cycle

    # Tag-to-flow mappings
    flow_mappings:
      - tags: [prototype, poc, spike]
        flow: rapid_prototype_flow
      - tags: [experiment, research]
        flow: experimental_flow

    # Emergency transitions
    emergency_transitions: [blocked, on-hold, archived]

    # Terminal statuses
    terminal_statuses: [completed, archived]

    # Status roles - semantic annotations for AI context
    # Roles: queue (waiting), work (active), review (validation), blocked (impediment), terminal (done)
    status_roles:
      draft: queue
      planning: queue
      in-development: work
      testing: review
      validating: review
      pending-review: review
      blocked: blocked
      on-hold: blocked
      completed: terminal
      archived: terminal

  tasks:
    # All valid task statuses (v2.0) - 11 total statuses
    # Valid task statuses (defined by TaskStatus enum):
    # backlog, pending, in-progress, in-review, changes-requested, testing,
    # blocked, on-hold, completed, cancelled, deferred, deployed, ready-for-qa, investigating
    #
    # BACKLOG: Task in backlog awaiting prioritization and planning.
    #          Use when: Task identified but not yet scheduled or prioritized.
    #          Next steps: Prioritize task, then move to PENDING.
    #
    # PENDING: Task ready to start, waiting for specialist assignment or available resources.
    #          Use when: Task prioritized and ready for implementation, dependencies met.
    #          Next steps: Assign specialist, move to IN_PROGRESS.
    #
    # IN_PROGRESS: Task actively being worked on by specialist (code being written, docs being drafted).
    #              Use when: Specialist is actively implementing the task.
    #              Next steps: Implementation complete, move to IN_REVIEW or TESTING.
    #
    # IN_REVIEW: Implementation complete, awaiting code review or peer validation.
    #            Use when: Code/work complete and needs human review before testing.
    #            Next steps: Review approved → TESTING, changes needed → CHANGES_REQUESTED.
    #
    # CHANGES_REQUESTED: Review completed with requested changes; task needs rework.
    #                    Use when: Reviewer requests modifications before approval.
    #                    Next steps: Implement changes (back to IN_PROGRESS), then re-submit for IN_REVIEW.
    #
    # TESTING: Running automated test suite or manual QA as a separate phase.
    #          Use when: Task is tagged qa-required or manual-test, requiring explicit QA.
    #          Not in default flow — used by with_testing_flow and hotfix_flow.
    #          Next steps: Tests pass → COMPLETED, tests fail → IN_PROGRESS for fixes.
    #
    # BLOCKED: Task blocked by incomplete dependencies or external issues (API down, missing specs).
    #          Use when: Cannot proceed until blocker is resolved.
    #          Next steps: Resolve blocker, then resume previous status.
    #
    # ON_HOLD: Task temporarily paused due to resource constraints, priority changes, or pending decisions.
    #          Use when: Work intentionally paused (waiting for approval, budget, design decisions).
    #          Next steps: Resume when ready, return to previous status or IN_PROGRESS.
    #
    # COMPLETED: Task finished, validated, and merged/delivered.
    #            Use when: All work complete, tests pass, review approved.
    #            Terminal status: No further progression.
    #
    # CANCELLED: Task explicitly cancelled by user or stakeholder (requirements changed, no longer needed).
    #            Use when: Task work abandoned and will not be completed.
    #            Terminal status: No further progression.
    #
    # DEFERRED: Task postponed indefinitely; may be resumed in future release or sprint.
    #           Use when: Task delayed but not cancelled (low priority, resource constraints).
    #           Terminal status: No further progression (but can be "undeferred" by creating new task).

    # Default flow — optimized for AI-driven development (no separate QA phase)
    default_flow: [backlog, pending, in-progress, completed]

    # Alternative flows for different task types
    bug_fix_flow: [pending, in-progress, completed]  # Skip backlog
    documentation_flow: [pending, in-progress, in-review, completed]  # No testing
    hotfix_flow: [in-progress, testing, completed]  # Emergency, skip backlog+pending
    with_review_flow: [backlog, pending, in-progress, in-review, changes-requested, testing, completed]  # Full review cycle
    with_testing_flow: [backlog, pending, in-progress, testing, completed]  # Separate QA phase

    # Tag-to-flow mappings (priority order matters - first match wins)
    flow_mappings:
      - tags: [bug, bugfix, fix]
        flow: bug_fix_flow
      - tags: [documentation, docs]
        flow: documentation_flow
      - tags: [hotfix, emergency, urgent]
        flow: hotfix_flow
      - tags: [qa-required, manual-test]
        flow: with_testing_flow
    # If no tags match, default_flow is used

    # Statuses that can be entered from any state
    emergency_transitions: [blocked, on-hold, cancelled, deferred]

    # Terminal statuses (no progression from these)
    terminal_statuses: [completed, cancelled, deferred]

    # Status roles - semantic annotations for AI context
    # Roles: queue (waiting), work (active), review (validation), blocked (impediment), terminal (done)
    status_roles:
      backlog: queue
      pending: queue
      in-progress: work
      in-review: review
      changes-requested: work
      testing: review
      ready-for-qa: review
      investigating: work
      blocked: blocked
      on-hold: blocked
      completed: terminal
      cancelled: terminal
      deferred: terminal

  projects:
    # All valid project statuses (v2.0) - 7 total statuses
    # Valid project statuses (defined by ProjectStatus enum):
    # planning, in-development, on-hold, deployed, cancelled, completed, archived
    #
    # PLANNING: Defining project scope, features, timeline, and resource allocation.
    #           Use when: Project initiated and high-level planning underway.
    #           Next steps: Complete feature breakdown, move to IN_DEVELOPMENT.
    #
    # IN_DEVELOPMENT: Active development of features by specialists.
    #                 Use when: Features are being actively implemented.
    #                 Next steps: Complete all features, move to COMPLETED.
    #
    # ON_HOLD: Project temporarily paused due to resource constraints, budget issues, or strategic priority changes.
    #          Use when: Project work intentionally suspended (waiting for funding, stakeholder decisions, etc.).
    #          Emergency status: Can be entered from any state.
    #          Next steps: Resume when conditions improve, return to PLANNING or IN_DEVELOPMENT.
    #
    # DEPLOYED: Project deployed to production or staging environment.
    #           Use when: Project has been released to an environment.
    #           Terminal status: No further progression.
    #
    # CANCELLED: Project cancelled or abandoned (requirements changed, no longer viable, superseded by another project).
    #            Use when: Project will not be completed and is permanently stopped.
    #            Emergency status: Can be entered from any state.
    #            Terminal status: No further progression.
    #
    # COMPLETED: Project finished and delivered to production or stakeholders.
    #            Use when: All features complete, project goals achieved.
    #            Terminal status: No further progression (but can be archived later).
    #
    # ARCHIVED: Project archived for historical reference (completed long ago, obsolete, or replaced).
    #           Use when: Project no longer active but kept for documentation/reference purposes.
    #           Terminal status: No further progression.

    # Default project flow
    default_flow: [planning, in-development, completed, archived]

    # Alternative flows
    with_deploy_flow: [planning, in-development, completed, deployed, archived]

    # Emergency transitions
    emergency_transitions: [on-hold, cancelled]

    # Terminal statuses
    terminal_statuses: [completed, archived, cancelled, deployed]

    # Status roles - semantic annotations for AI context
    # Roles: queue (waiting), work (active), blocked (impediment), terminal (done)
    status_roles:
      planning: queue
      in-development: work
      on-hold: blocked
      deployed: terminal
      cancelled: terminal
      completed: terminal
      archived: terminal

# ============================================================================
# STATUS VALIDATION RULES (✅ IMPLEMENTED)
# ============================================================================
# Advanced validation rules for status transitions
#
# IMPLEMENTATION: StatusValidator.kt enforces these rules when config is present
# The validator supports flexible workflows with safety guardrails
#
# These rules control how strictly the system enforces workflow progression,
# enabling teams to balance process rigor with practical flexibility.

status_validation:
  # Enforce strict sequential flow (can't skip statuses in defined flows)
  # When true: Must follow default_flow or alternative flows step-by-step
  # When false: Can jump to any allowed status
  #
  # Example with enforce_sequential=true:
  #   ✅ Allowed: pending → in-progress → testing → completed (follows flow)
  #   ❌ Blocked: pending → completed (skips in-progress and testing)
  #
  # Example with enforce_sequential=false:
  #   ✅ Allowed: pending → completed (can skip intermediate steps)
  #
  # Recommendation: Keep true for teams needing process compliance (code review, testing gates).
  #                 Set false for rapid prototyping or small teams with informal processes.
  enforce_sequential: true

  # Allow backward transitions (e.g., testing → in-progress for rework)
  # When true: Can move backwards in flow to fix issues
  # When false: Can only move forward
  #
  # Example with allow_backward=true:
  #   ✅ Allowed: in-review → in-progress (fix review comments)
  #   ✅ Allowed: testing → in-progress (fix failing tests)
  #
  # Example with allow_backward=false:
  #   ❌ Blocked: testing → in-progress (must create new task for fixes)
  #
  # Recommendation: Keep true for iterative development workflows (review cycles, test-fix loops).
  #                 Set false only if your process requires forward-only progression.
  allow_backward: true

  # Allow emergency transitions (blocked, on-hold, archived, cancelled, deferred)
  # When true: Can enter emergency_transitions from any state
  # When false: Emergency statuses follow normal flow rules
  #
  # Example with allow_emergency=true:
  #   ✅ Allowed: in-progress → blocked (dependency fails)
  #   ✅ Allowed: testing → on-hold (urgent priority change)
  #   ✅ Allowed: planning → cancelled (requirements changed)
  #
  # Example with allow_emergency=false:
  #   ❌ Blocked: in-progress → blocked (must follow normal flow)
  #
  # Recommendation: Keep true to handle unexpected blockers, priority shifts, and cancellations.
  #                 Emergency statuses are critical for real-world workflow flexibility.
  allow_emergency: true

  # Validate prerequisites before status change (feature must have tasks, etc.)
  # When true: Enforces business rules like "feature needs tasks before completion"
  # When false: Allows status changes without prerequisite checks
  #
  # Example prerequisite validations (when true):
  #   - Feature cannot move to IN_DEVELOPMENT without at least one task
  #   - Task cannot move to COMPLETED if blocked by incomplete dependencies
  #   - Feature cannot complete if it has incomplete tasks
  #
  # Note: Currently enforces basic validation; full prerequisite system planned for future releases.
  #
  # Recommendation: Keep true to prevent incomplete work from being marked complete.
  #                 Set false only for testing or if managing prerequisites externally.
  validate_prerequisites: true

# ============================================================================
# COMPLETION CLEANUP CONFIGURATION
# ============================================================================
# When a feature reaches a terminal status (defined in status_progression.features.terminal_statuses),
# automatically delete child tasks. Features and projects are preserved — they contain
# the durable record of work. Tasks are transient work items that served their purpose.
#
# IMPLEMENTATION: CompletionCleanupService runs synchronously during status transitions
# in both request_transition and manage_container(setStatus) tools.
#
# What gets cleaned up:
# - Child tasks of the feature (with their sections and dependencies)
#
# What is NOT cleaned up:
# - The feature itself and its sections (preserved for long-term context)
# - Bug-tagged tasks (retained for diagnostic value, configurable via retain_tags)
# - Standalone tasks with no featureId
# - Projects (never deleted)

completion_cleanup:
  # Master switch for automatic cleanup. Set to false to keep all tasks indefinitely.
  enabled: false

  # Tasks with any of these tags survive cleanup. Checked case-insensitively against task tags.
  # Common patterns: bug reports, critical fixes, hotfixes that have diagnostic value.
  retain_tags: [bug, bugfix, fix, hotfix, critical]

# ============================================================================
# AUTO-CASCADE CONFIGURATION
# ============================================================================
# When a status transition triggers cascade events (e.g., completing a task
# triggers feature advancement), automatically apply the cascaded transitions
# instead of returning them as suggestions.
#
# Cascade chain example:
#   Task completed -> all_tasks_complete -> Feature advances to "completed"
#   Feature completed -> all_features_complete -> Project advances to "completed"
#
# IMPLEMENTATION: RequestTransitionTool applies cascades recursively after each
# transition, up to max_depth. Cascaded transitions respect StatusValidator
# checks and verification gates.

auto_cascade:
  # Master switch. When false, cascade events are still detected and returned
  # in the response but NOT automatically applied (legacy behavior).
  enabled: true

  # Maximum cascade depth. Prevents runaway recursion.
  # Depth 1: task -> feature (one step)
  # Depth 2: task -> feature (one step) -> feature (next step)
  # Depth 10: Allows multi-step progression through intermediate statuses
  max_depth: 10

  # Start cascade (role-based) — auto-advance parent when first child reaches work role.
  # Rule 1: first child queue→work AND parent is queue → parent queue→work
  # Rule 2: all children reach review+ AND parent is work (with review-phase schema) → parent work→review
  # No status strings involved — purely role comparisons.
  start_cascade:
    enabled: true

# ============================================================================
# SETUP CHECK CONFIGURATION
# ============================================================================
# Controls the Claude Code plugin SessionStart hook that verifies setup
# instructions are installed in the project's agent instructions file.
#
# When enabled (default), the hook checks for a version marker comment
# (<!-- mcp-task-orchestrator-setup: vN -->) in common instruction files
# (CLAUDE.md, .cursorrules, .windsurfrules). If missing or outdated,
# it injects guidance to read the MCP resource and install the block.
#
# Set to false for projects that manage their own workflow configuration
# (e.g., the Task Orchestrator project itself).

setup_check_enabled: true
