# v2.0 Enhanced Filtering Design

## Overview

This document outlines the comprehensive enhancements to the search and filtering capabilities in Task Orchestrator v2.0, addressing:

1. **Multi-value filters** - Search for multiple statuses/priorities in one query
2. **Negation filters** - Exclude specific values (e.g., "NOT completed")
3. **Minimal search results** - Return only essential fields to reduce token usage
4. **Task counts in features/projects** - Efficient status checking without fetching all tasks

## Current Limitations (v2.0-beta-01)

### Problem 1: Single-Value Filters
```typescript
// ❌ Current: Can only filter by ONE status
query_container(operation="search", containerType="task", status="pending")

// ❌ To get pending OR in-progress, need 2 queries + manual merge
query_container(..., status="pending")     // Query 1
query_container(..., status="in-progress") // Query 2
// Agent must merge and deduplicate results manually
```

### Problem 2: No Negation
```typescript
// ❌ Current: Can't express "NOT completed"
// Must query ALL tasks, then filter client-side
// Or query each non-completed status individually

// Workaround requires 4 queries for tasks:
query_container(..., status="pending")
query_container(..., status="in-progress")
query_container(..., status="cancelled")
query_container(..., status="deferred")
```

### Problem 3: Verbose Search Results
```typescript
// ❌ Current: Search returns FULL task objects (~280 tokens each)
// For 50 tasks: ~14,400 tokens
// Even when agent only needs: id, title, status (~30 tokens each)
```

### Problem 4: No Efficient Task Counts
```typescript
// ❌ Current: To check feature progress, must fetch ALL tasks
query_container(operation="search", containerType="task", featureId="...", limit=50)
// Returns 50 full task objects (~14,400 tokens)
// Just to count: 25 completed, 15 in-progress, 10 pending
```

## Enhanced Design

### 1. Multi-Value Filter Syntax

**String-based comma-separated values with `!` prefix for negation:**

```typescript
// Include multiple values (OR logic)
status = "pending,in-progress"          // pending OR in-progress
priority = "high,medium"                // high OR medium

// Exclude values (NOT logic)
status = "!completed"                   // NOT completed
status = "!completed,!cancelled"        // NOT completed AND NOT cancelled
priority = "!low"                       // NOT low

// Mixed (not recommended, but supported)
status = "pending,!cancelled"           // pending OR (NOT cancelled)
```

**Parsing Rules:**
1. Split by comma (`,`)
2. Trim whitespace
3. If starts with `!`, add to exclude list
4. Otherwise, add to include list
5. Apply as: `(status IN include) AND (status NOT IN exclude)`

### 2. Data Model

**New filter model classes in `domain/model/`:**

```kotlin
/**
 * Filter for status fields supporting multi-value inclusion/exclusion.
 */
data class StatusFilter<T>(
    val include: List<T> = emptyList(),  // Match ANY of these (OR)
    val exclude: List<T> = emptyList()   // Match NONE of these (AND NOT)
) {
    fun isEmpty(): Boolean = include.isEmpty() && exclude.isEmpty()

    fun matches(value: T): Boolean {
        if (exclude.contains(value)) return false
        if (include.isNotEmpty() && !include.contains(value)) return false
        return true
    }
}

/**
 * Filter for priority field supporting multi-value inclusion/exclusion.
 */
typealias PriorityFilter = StatusFilter<Priority>
```

### 3. Repository Interface Changes

**Update `BaseRepository.kt` interfaces:**

```kotlin
interface FilterableRepository<T, TStatus, TPriority> : TaggableRepository<T> {
    /**
     * Advanced filtering with multiple criteria.
     *
     * @param statusFilter Multi-value status filter (include/exclude)
     * @param priorityFilter Multi-value priority filter (include/exclude)
     */
    suspend fun findByFilters(
        projectId: UUID? = null,
        statusFilter: StatusFilter<TStatus>? = null,      // CHANGED
        priorityFilter: StatusFilter<TPriority>? = null,  // CHANGED
        tags: List<String>? = null,
        textQuery: String? = null,
        limit: Int = 20,
    ): Result<List<T>>

    // Add new method for counting with filters
    suspend fun countByFilters(
        projectId: UUID? = null,
        statusFilter: StatusFilter<TStatus>? = null,
        priorityFilter: StatusFilter<TPriority>? = null,
        tags: List<String>? = null,
        textQuery: String? = null
    ): Result<Long>
}
```

### 4. SQLite Repository Implementation

**Update query builders in `SQLiteBusinessEntityRepository.kt`:**

```kotlin
override suspend fun findByFilters(
    projectId: UUID?,
    statusFilter: StatusFilter<TStatus>?,
    priorityFilter: StatusFilter<TPriority>?,
    tags: List<String>?,
    textQuery: String?,
    limit: Int,
): Result<List<T>> = withContext(Dispatchers.IO) {
    try {
        val entities = transaction {
            var query = table.selectAll()

            // Apply status filter
            if (statusFilter != null && !statusFilter.isEmpty()) {
                val statusColumn = getStatusColumn()
                if (statusColumn != null) {
                    // Include: status IN (...)
                    if (statusFilter.include.isNotEmpty()) {
                        query = query.andWhere {
                            statusColumn inList statusFilter.include
                        }
                    }
                    // Exclude: status NOT IN (...)
                    if (statusFilter.exclude.isNotEmpty()) {
                        query = query.andWhere {
                            statusColumn notInList statusFilter.exclude
                        }
                    }
                }
            }

            // Apply priority filter
            if (priorityFilter != null && !priorityFilter.isEmpty()) {
                val priorityColumn = getPriorityColumn()
                if (priorityColumn != null) {
                    if (priorityFilter.include.isNotEmpty()) {
                        query = query.andWhere {
                            priorityColumn inList priorityFilter.include
                        }
                    }
                    if (priorityFilter.exclude.isNotEmpty()) {
                        query = query.andWhere {
                            priorityColumn notInList priorityFilter.exclude
                        }
                    }
                }
            }

            // ... rest of filtering logic
        }

        Result.Success(entities)
    } catch (e: Exception) {
        Result.Error(RepositoryError.DatabaseError(e.message))
    }
}
```

### 5. QueryContainerTool Changes

**Add parsing helper methods:**

```kotlin
private fun parseStatusFilter(
    statusParam: String?,
    containerType: String
): StatusFilter<*>? {
    if (statusParam.isNullOrBlank()) return null

    val parts = statusParam.split(",").map { it.trim() }
    val include = mutableListOf<Any>()
    val exclude = mutableListOf<Any>()

    parts.forEach { part ->
        if (part.startsWith("!")) {
            // Negation: remove ! and parse
            val status = parseStatus(part.substring(1), containerType)
            exclude.add(status)
        } else {
            val status = parseStatus(part, containerType)
            include.add(status)
        }
    }

    return when (containerType) {
        "task" -> StatusFilter(
            include = include.filterIsInstance<TaskStatus>(),
            exclude = exclude.filterIsInstance<TaskStatus>()
        )
        "feature" -> StatusFilter(
            include = include.filterIsInstance<FeatureStatus>(),
            exclude = exclude.filterIsInstance<FeatureStatus>()
        )
        "project" -> StatusFilter(
            include = include.filterIsInstance<ProjectStatus>(),
            exclude = exclude.filterIsInstance<ProjectStatus>()
        )
        else -> null
    }
}

private fun parseStatus(value: String, containerType: String): Any {
    return when (containerType) {
        "task" -> parseTaskStatus(value)
        "feature" -> parseFeatureStatus(value)
        "project" -> parseProjectStatus(value)
        else -> throw IllegalArgumentException("Unknown container type")
    }
}
```

**Update search execution:**

```kotlin
private suspend fun searchTasks(params: JsonElement, context: ToolExecutionContext): JsonElement {
    val query = optionalString(params, "query")
    val statusParam = optionalString(params, "status")
    val priorityParam = optionalString(params, "priority")

    // Parse multi-value filters
    val statusFilter = parseStatusFilter(statusParam, "task") as StatusFilter<TaskStatus>?
    val priorityFilter = parsePriorityFilter(priorityParam) as StatusFilter<Priority>?

    val tagsStr = optionalString(params, "tags")
    val tags = tagsStr?.split(",")?.map { it.trim() }?.filter { it.isNotEmpty() }
    val featureId = optionalString(params, "featureId")?.let { UUID.fromString(it) }
    val limit = optionalInt(params, "limit") ?: 20

    // Call repository with new filter objects
    val result = if (featureId != null) {
        context.taskRepository().findByFeatureAndFilters(
            featureId = featureId,
            statusFilter = statusFilter,
            priorityFilter = priorityFilter,
            tags = tags,
            textQuery = query,
            limit = limit
        )
    } else {
        context.taskRepository().findByFilters(
            statusFilter = statusFilter,
            priorityFilter = priorityFilter,
            tags = tags,
            textQuery = query,
            limit = limit
        )
    }

    return when (result) {
        is Result.Success -> {
            val tasks = result.data
            successResponse(
                buildJsonObject {
                    put("items", buildJsonArray {
                        tasks.forEach { task ->
                            add(buildTaskSearchResult(task))  // MINIMAL data
                        }
                    })
                    put("count", tasks.size)
                },
                "${tasks.size} task(s) found"
            )
        }
        is Result.Error -> errorResponse(...)
    }
}
```

### 6. Minimal Search Results

**New methods for minimal data (80-90% token reduction):**

```kotlin
private fun buildTaskSearchResult(task: Task): JsonObject {
    return buildJsonObject {
        put("id", task.id.toString())
        put("title", task.title)
        put("status", task.status.name.lowercase().replace('_', '-'))
        put("priority", task.priority.name.lowercase())
        put("complexity", task.complexity)
        task.featureId?.let { put("featureId", it.toString()) }
        // NO summary, NO description, NO tags, NO timestamps
    }
}

private fun buildFeatureSearchResult(feature: Feature): JsonObject {
    return buildJsonObject {
        put("id", feature.id.toString())
        put("name", feature.name)
        put("status", feature.status.name.lowercase().replace('_', '-'))
        put("priority", feature.priority.name.lowercase())
        feature.projectId?.let { put("projectId", it.toString()) }
    }
}

private fun buildProjectSearchResult(project: Project): JsonObject {
    return buildJsonObject {
        put("id", project.id.toString())
        put("name", project.name)
        put("status", project.status.name.lowercase().replace('_', '-'))
    }
}
```

**Token comparison:**
- Full task object: ~280 tokens
- Minimal task result: ~30 tokens
- **Savings: 89% reduction**

### 7. Task Counts in Get Operations

**Always include taskCounts for features/projects (trivial cost):**

```kotlin
private suspend fun getFeature(context: ToolExecutionContext, id: UUID, includeSections: Boolean): JsonElement {
    return when (val result = context.featureRepository().getById(id)) {
        is Result.Success -> {
            val feature = result.data

            // Always fetch task counts (very cheap - just COUNT queries)
            val taskCounts = context.taskRepository()
                .findByFeature(id)
                .let { tasksResult ->
                    if (tasksResult is Result.Success) {
                        val tasks = tasksResult.data
                        buildJsonObject {
                            put("total", tasks.size)
                            put("byStatus", buildJsonObject {
                                tasks.groupBy { it.status }
                                    .forEach { (status, taskList) ->
                                        put(
                                            status.name.lowercase().replace('_', '-'),
                                            taskList.size
                                        )
                                    }
                            })
                        }
                    } else {
                        buildJsonObject {
                            put("total", 0)
                            put("byStatus", buildJsonObject {})
                        }
                    }
                }

            val sections = if (includeSections) { ... } else emptyList()

            val featureJson = buildFeatureJson(feature, sections, includeSections)
            // Add taskCounts to response
            featureJson.put("taskCounts", taskCounts)

            successResponse(featureJson, "Feature retrieved successfully")
        }
        is Result.Error -> handleNotFoundError(result, "Feature", id)
    }
}
```

## Implementation Checklist

### Phase 1: Core Infrastructure
- [ ] Create `StatusFilter` data class in `domain/model/FilterModels.kt`
- [ ] Update `FilterableRepository` interface with new signatures
- [ ] Update `ProjectScopedRepository` interface
- [ ] Update `TaskRepository` with feature-scoped filter methods

### Phase 2: Repository Implementation
- [ ] Update `SQLiteBusinessEntityRepository.findByFilters()`
- [ ] Update `SQLiteTaskRepository.findByFilters()`
- [ ] Update `SQLiteTaskRepository.findByFeatureAndFilters()`
- [ ] Update `SQLiteFeatureRepository.findByFilters()`
- [ ] Update `SQLiteProjectRepository.findByFilters()`

### Phase 3: Tool Updates
- [ ] Add filter parsing helpers to `QueryContainerTool`
- [ ] Update `searchTasks()` to use new filters
- [ ] Update `searchFeatures()` to use new filters
- [ ] Update `searchProjects()` to use new filters
- [ ] Add minimal result builders
- [ ] Add taskCounts to `getFeature()`
- [ ] Add taskCounts to `getProject()`

### Phase 4: Testing
- [ ] Test single status filter (backward compat)
- [ ] Test multi-status inclusion: `"pending,in-progress"`
- [ ] Test status exclusion: `"!completed"`
- [ ] Test multi-exclusion: `"!completed,!cancelled"`
- [ ] Test priority filters (same patterns)
- [ ] Test combined filters (status + priority + tags + text)
- [ ] Test minimal search results format
- [ ] Test taskCounts in feature/project responses
- [ ] Performance test: 1000+ tasks with complex filters

### Phase 5: Documentation
- [ ] Update `QueryContainerTool` description with examples
- [ ] Update `docs/api-reference.md` with new filter syntax
- [ ] Update `docs/migration/v2.0-migration-guide.md`
- [ ] Update AI guidance in `.claude/skills/feature-management/SKILL.md`
- [ ] Update AI guidance in `.claude/skills/task-management/SKILL.md`
- [ ] Update agent prompts in `.claude/agents/*/`.md` files
- [ ] Add examples to `CHANGELOG.md`

## Migration Impact

**Breaking Changes:**
1. Repository interface signatures changed (internal only - no user impact)
2. Search results now return minimal data (agents will adapt)

**Non-Breaking:**
1. Single-value filters still work: `status="completed"` ✅
2. All existing queries remain valid

**Benefits:**
1. Agents can use 1 query instead of multiple queries + manual merge
2. 89% token reduction for search results
3. Efficient feature status checking (task counts)
4. More powerful filtering expressions

## Examples

### Before (Multiple Queries Required)

```typescript
// Get all non-completed tasks in a feature
// ❌ Required 4 separate queries:
query_container(operation="search", containerType="task", featureId="...", status="pending")
query_container(operation="search", containerType="task", featureId="...", status="in-progress")
query_container(operation="search", containerType="task", featureId="...", status="cancelled")
query_container(operation="search", containerType="task", featureId="...", status="deferred")
// Agent merges and sorts results manually
```

### After (Single Query)

```typescript
// Get all non-completed tasks in a feature
// ✅ Single query:
query_container(
  operation="search",
  containerType="task",
  featureId="...",
  status="!completed"
)
```

### Feature Status Check

**Before:**
```typescript
// ❌ Fetch all 50 tasks (~14,400 tokens)
query_container(
  operation="search",
  containerType="task",
  featureId="...",
  limit=50
)
// Agent counts statuses manually
```

**After:**
```typescript
// ✅ Get feature with counts (~100 tokens)
query_container(
  operation="get",
  containerType="feature",
  id="..."
)
// Response includes:
// {
//   "taskCounts": {
//     "total": 50,
//     "byStatus": {
//       "completed": 25,
//       "in-progress": 15,
//       "pending": 10
//     }
//   }
// }
```

## Performance Considerations

1. **SQL Efficiency**: `IN` and `NOT IN` clauses are well-optimized in SQLite
2. **Index Usage**: Status and priority columns should have indexes
3. **Token Savings**: Minimal search results save 80-90% tokens
4. **Query Reduction**: Multi-value filters eliminate multiple round-trips

## Future Enhancements (Post-v2.0)

1. **Complexity range filters**: `complexity="3-7"` or `complexity=">5"`
2. **Date range filters**: `createdAfter="2025-01-01"`
3. **Combined text operators**: `textQuery="api AND !deprecated"`
4. **Sorting**: `sortBy="priority,createdAt"`
5. **Pagination cursors**: For very large result sets
